---
title: 索引覆盖-猜测.md
top: false
cover: false
toc: true
mathjax: true
date: 2022-03-20 18:16:49
password:
summary:
tags: mysql基本
categories: mysql基本
---
---
title: 索引覆盖-猜测.md
top: false
cover: false
toc: true
mathjax: true
date: 2022-03-20 18:16:49
password:
summary:
tags: mysql基本
categories: mysql基本
---
出现Using index condition、null 则表示当前建立的索引无法满足select查询字段的需要，需要回表查了。此时效率比较低；



###索引覆盖出现的判断依据 

查* ，出现 Using index condition

查id，出现 Using where; Using index

~~~
mysql>  EXPLAIN SELECT *
 FROM jg_original_order force index(idx_main_platform_order_no)
 WHERE (main_platform_order_no IN ('|202111180008435318','|20211118000843531239','|2021111800084353151','|20211118000843531622','|202111180008435317','|202111180008435314','|202111180008435323','|202111180008435313','|202111180008435312410','|20211118000843531223','|20211118000811','|2021111800084312'));
+----+-------------+-------------------+------------+-------+----------------------------+----------------------------+---------+------+------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys              | key                        | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+----------------------------+----------------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | jg_original_order | NULL       | range | idx_main_platform_order_no | idx_main_platform_order_no | 403     | NULL |   12 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+----------------------------+----------------------------+---------+------+------+----------+-----------------------+
1 row in set (0.02 sec)

mysql> EXPLAIN SELECT id
 FROM jg_original_order force index(idx_main_platform_order_no)
 WHERE (main_platform_order_no IN ('|202111180008435318','|20211118000843531239','|2021111800084353151','|20211118000843531622','|202111180008435317','|202111180008435314','|202111180008435323','|202111180008435313','|202111180008435312410','|20211118000843531223','|20211118000811','|2021111800084312'));
+----+-------------+-------------------+------------+-------+----------------------------+----------------------------+---------+------+------+----------+--------------------------+
| id | select_type | table             | partitions | type  | possible_keys              | key                        | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+-------------------+------------+-------+----------------------------+----------------------------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | jg_original_order | NULL       | range | idx_main_platform_order_no | idx_main_platform_order_no | 403     | NULL |   12 |   100.00 | Using where; Using index |
+----+-------------+-------------------+------------+-------+----------------------------+----------------------------+---------+------+------+----------+--------------------------+
1 row in set (0.02 sec)

mysql> 
~~~

####为什么上面我没有建立id的子部分索引，select id却能做到索引覆盖？
辅助索引的叶子节点不仅仅存了键值而且还存了主键值



####2、对于等值查询

查* ，出现 NULL

查id，出现 Using index


~~~
mysql>  EXPLAIN SELECT *
 FROM jg_order_excel_field 
 WHERE (template_no = 'CP20220110008' AND del_status = 0);
+----+-------------+----------------------+------------+------+----------------------------+----------------------------+---------+-------------+------+----------+-------+
| id | select_type | table                | partitions | type | possible_keys              | key                        | key_len | ref         | rows | filtered | Extra |
+----+-------------+----------------------+------------+------+----------------------------+----------------------------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | jg_order_excel_field | NULL       | ref  | idx_template_no_del_status | idx_template_no_del_status | 197     | const,const |   58 |   100.00 | NULL  |
+----+-------------+----------------------+------------+------+----------------------------+----------------------------+---------+-------------+------+----------+-------+
1 row in set (0.02 sec)

mysql>  EXPLAIN SELECT id
 FROM jg_order_excel_field 
 WHERE (template_no = 'CP20220110008' AND del_status = 0);
+----+-------------+----------------------+------------+------+----------------------------+----------------------------+---------+-------------+------+----------+-------------+
| id | select_type | table                | partitions | type | possible_keys              | key                        | key_len | ref         | rows | filtered | Extra       |
+----+-------------+----------------------+------------+------+----------------------------+----------------------------+---------+-------------+------+----------+-------------+
|  1 | SIMPLE      | jg_order_excel_field | NULL       | ref  | idx_template_no_del_status | idx_template_no_del_status | 197     | const,const |   58 |   100.00 | Using index |
+----+-------------+----------------------+------------+------+----------------------------+----------------------------+---------+-------------+------+----------+-------------+
1 row in set (0.03 sec)

mysql> 
~~~
####如下语句为什么也能用到索引覆盖？
where条件中没有spu，为什么也能用到using index？
原因：只是求数量，不需要访问实际列；通过扫描辅助索引 stock_product ，然后然后using where进行过滤。再对主键进行count。完全不需要回到聚簇索引中查。
执行过程：通过去除所有辅助索引数据，然后using where进行过滤

这个语句最优的做法是只建立索引idx_create_time 
~~~
mysql> EXPLAIN SELECT
	count( * ) 
FROM
	stock_product 
WHERE
	create_time > '2011-01-01' 
	AND create_time < '2011-02-01';
+----+-------------+---------------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+
| id | select_type | table         | partitions | type  | possible_keys | key              | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+---------------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | stock_product | NULL       | index | NULL          | spu, create_time | 307     | NULL |    1 |   100.00 | Using where; Using index |
+----+-------------+---------------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+
1 row in set (0.02 sec)

mysql> 
~~~

###索引覆盖的索引我们要怎么加？
1、索引覆盖与最左匹配原则没有任何关系，不要在意联合索引的组成顺序问题。只要索引字部分中存在就行
2、索引覆盖只能通过Extra来看出来
3、索引覆盖使用的索引长度不会计入key_len
4、索引覆盖使用的索引会出现在key里面（除了primary key）
5、索引覆盖也可以使用force index指定选择哪个索引
6、`正确` 索引覆盖的索引和 where、join用到的索引必须是同一个
7、多条件就必须是联合索引，这个时候使用单值索引做索引覆盖是不行的
8、对于id主键，可以不用特别加在复合索引里。









###有没有这种情况？where中未使用索引，但是有存在索引覆盖
答：不可能存在，首先得where、join中使用到了索引。才能继续判断是不是用了索引覆盖！

###索引覆盖性能一点好吗
不一定，分具体情况。大部分是一个优秀的手段

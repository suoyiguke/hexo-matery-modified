---
title: mysql-join查询中条件写到ON或WHERE有什么区别？.md
top: false
cover: false
toc: true
mathjax: true
date: 2022-03-20 18:16:49
password:
summary:
tags: mysql基本
categories: mysql基本
---
---
title: mysql-join查询中条件写到ON或WHERE有什么区别？.md
top: false
cover: false
toc: true
mathjax: true
date: 2022-03-20 18:16:49
password:
summary:
tags: mysql基本
categories: mysql基本
---
准备数据
~~~
create table a(f1 int, f2 int, index(f1))engine=innodb;
create table b(f1 int, f2 int)engine=innodb;
insert into a values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6);
insert into b values(3,3),(4,4),(5,5),(6,6),(7,7),(8,8);
~~~

###left join
~~~
select * from a left join b on(a.f1=b.f1) and (a.f2=b.f2); /*Q1*/
select * from a left join b on(a.f1=b.f1) where (a.f2=b.f2);/*Q2*/
~~~
我们先对比下Q1和Q2的执行计划：

Q1的explain结果：
~~~
mysql> explain select * from a left join b on(a.f1=b.f1) and (a.f2=b.f2);
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra
  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
|  1 | SIMPLE      | a     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |   100.00 | NULL
  |
|  1 | SIMPLE      | b     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |   100.00 | Using where; Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
2 rows in set, 1 warning (0.00 sec)
~~~

可以看到，这个结果符合我们的预期：
*   驱动表是表a，被驱动表是表b；
*   由于表b的f1字段上没有索引，所以使用的是Block Nexted Loop Join（简称BNL） 算法。

看到BNL算法，你就应该知道这条语句的执行流程其实是这样的：
1.  把表a的内容读入join_buffer 中。因为是select * ，所以字段f1和f2都被放入join_buffer了。
2.  顺序扫描表b，对于每一行数据，判断join条件（也就是a.f1=b.f1 and a.f2=b.f2)是否满足，满足条件的记录, 作为结果集的一行返回。如果语句中有where子句，需要先判断where部分满足条件后，再返回。
3.  表b扫描完成后，对于没有被匹配的表a的行（在这个例子中就是(1,1)、(2,2)这两行），把剩余字段补上NULL，再放入结果集中。


Q2的expain结果
~~~
mysql> explain select * from a left join b on(a.f1=b.f1) where (a.f2=b.f2);
+----+-------------+-------+------------+------+---------------+------+---------+---------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref     | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+---------+------+----------+-------------+
|  1 | SIMPLE      | b     | NULL       | ALL  | NULL          | NULL | NULL    | NULL    |    6 |   100.00 | Using where |
|  1 | SIMPLE      | a     | NULL       | ref  | f1            | f1   | 5       | sy.b.f1 |    1 |    16.67 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+---------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
~~~
而如果一条join语句的Extra字段什么都没写的话，就表示使用的是Index Nested-Loop Join（简称NLJ）算法。

因此，语句Q2的执行流程是这样的：
顺序扫描表b，每一行用b.f1到表a中去查，匹配到记录后判断a.f2=b.f2是否满足，满足条件的话就作为结果集的一部分返回。


那么，**为什么语句Q1和Q2这两个查询的执行流程会差距这么大呢？**其实，这是因为优化器基于Q2这个查询的语义做了优化。

为了理解这个问题，我需要再和你交代一个背景知识点：
在MySQL里，NULL跟任何值执行等值判断和不等值判断的结果，都是NULL。这里包括， select NULL = NULL 的结果，也是返回NULL。

因此，语句Q2里面where a.f2=b.f2就表示，查询结果里面不会包含b.f2是NULL的行，这样这个left join的语义就是“找到这两个表里面，f1、f2对应相同的行。对于表a中存在，而表b中匹配不到的行，就放弃”。

这样，这条语句虽然用的是left join，但是语义跟join是一致的。

因此，优化器就把这条语句的left join改写成了join，然后因为表a的f1上有索引，就把表b作为驱动表，这样就可以用上NLJ 算法。在执行explain之后，你再执行show warnings，就能看到这个改写的结果：如下left join 已被改写为join：
~~~
mysql> explain select * from a join b on(a.f1=b.f1) where (a.f2=b.f2);
+----+-------------+-------+------------+------+---------------+------+---------+---------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref     | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+---------+------+----------+-------------+
|  1 | SIMPLE      | b     | NULL       | ALL  | NULL          | NULL | NULL    | NULL    |    6 |   100.00 | Using where |
|  1 | SIMPLE      | a     | NULL       | ref  | f1            | f1   | 5       | sy.b.f1 |    1 |    16.67 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+---------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)

mysql> show warnings;
+-------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Level | Code | Message
                                                                           |
+-------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Note  | 1003 | /* select#1 */ select `sy`.`a`.`f1` AS `f1`,`sy`.`a`.`f2` AS `f2`,`sy`.`b`.`f1` AS `f1`,`sy`.`b`.`f2` AS `f2` from `sy`.`a` join `sy`.`b` where ((`sy`.`a`.`f1` = `sy`.`b`.`f1`) and (`sy`.`a`.`f2` = `sy`.`b`.`f2`)) |
+-------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)

~~~

这个例子说明，即使我们在SQL语句中写成left join，执行过程还是有可能不是从左到右连接的。也就是说，**使用left join时，左边的表不一定是驱动表。**



这样看来，**如果需要left join的语义，就不能把被驱动表的字段放在where条件里面做等值判断或不等值判断，必须都写在on里面。**

>结论：编写left join 时若后面加了where条件，则此left join会被mysql改写为join

那如果是join语句呢？

###join
~~~
select * from a join b on(a.f1=b.f1) and (a.f2=b.f2); /*Q3*/
select * from a join b on(a.f1=b.f1) where (a.f2=b.f2);/*Q4*/
~~~

来看Q4的explain 
~~~
mysql> explain select * from a join b on(a.f1=b.f1) where (a.f2=b.f2);
+----+-------------+-------+------------+------+---------------+------+---------+---------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref     | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+---------+------+----------+-------------+
|  1 | SIMPLE      | b     | NULL       | ALL  | NULL          | NULL | NULL    | NULL    |    6 |   100.00 | Using where |
|  1 | SIMPLE      | a     | NULL       | ref  | f1            | f1   | 5       | sy.b.f1 |    1 |    16.67 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+---------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)

mysql> show warnings;
+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------+
| Level | Code | Message
                                                                           |
+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------+
| Note  | 1003 | /* select#1 */ select `sy`.`a`.`f1` AS `f1`,`sy`.`a`.`f2` AS `f2`,`sy`.`b`.`f1` AS `f1`,`sy`.`b`.`f2` AS `f2` from `sy`.`a` join `sy`.`b` w
here ((`sy`.`a`.`f1` = `sy`.`b`.`f1`) and (`sy`.`a`.`f2` = `sy`.`b`.`f2`)) |
+-------+------+--------------------------------------------------------------------------
~~~
可以看到，Q4语句被改写成：
select * from a join b where (a.f1=b.f1) and (a.f2=b.f2);
也就是说，在这种情况下，join将判断条件是否全部放在on部分就没有区别了。


###结论
1. 如果用left join的话，左边的表一定是驱动表吗？
  不一定; 如上Q2的left join 会被优化器改写为 join；故在这种情况下left join左表不是驱动表。

2.  如果两个表的join包含多个条件的等值匹配，是都要写到on里面呢，还是只把一个条件写到on里面，其他条件写到where部分？
普通join中写到on还是where执行上没有任何区别。因为where条件会被改写到on中；

---
title: mybatis--注解.md
top: false
cover: false
toc: true
mathjax: true
date: 2022-03-20 18:16:49
password:
summary:
tags: java持久化框架
categories: java持久化框架
---
---
title: mybatis--注解.md
top: false
cover: false
toc: true
mathjax: true
date: 2022-03-20 18:16:49
password:
summary:
tags: java持久化框架
categories: java持久化框架
---
###@ResultMap
1、@ResultMap("dataResult")指定    @Results的id 。重复使用声明的Results
~~~
package org.szwj.ca.identityauthsrv.dao;

import java.util.List;
import org.apache.ibatis.annotations.Result;
import org.apache.ibatis.annotations.ResultMap;
import org.apache.ibatis.annotations.Results;
import org.apache.ibatis.annotations.Select;
import org.apache.ibatis.type.JdbcType;
import org.springframework.stereotype.Repository;
import org.szwj.ca.identityauthsrv.entity.dao.TlkSignedDataWithBLOBs;

@Repository
public interface TlkSignedDataDao {



    /**
     * This method was generated by MyBatis Generator.
     * This method corresponds to the database table tlk_signed_data
     *
     * @mbg.generated Thu Jun 04 16:28:22 CST 2020
     */
    @Select({
        "select",
        "`ID`, `Authority`, `BusinessOrgCode`, `BusinessSystemCode`, `BusinessTypeCode`, ",
        "`Detach`, `DataDigest`, `CertInfoID`, `CreatedTime`, `LastTime`, `SourceData`, ",
        "`Base64SourceData`, `SignedData`, `Timestamp`, `SignCert`",
        "from tlk_signed_data",
        "where `ID` = #{id,jdbcType=VARCHAR}"
    })
    @Results(id="dataResult",value = {
        @Result(column="ID", property="id", jdbcType=JdbcType.VARCHAR, id=true),
        @Result(column="Authority", property="authority", jdbcType=JdbcType.VARCHAR),
        @Result(column="BusinessOrgCode", property="businessorgcode", jdbcType=JdbcType.VARCHAR),
        @Result(column="BusinessSystemCode", property="businesssystemcode", jdbcType=JdbcType.VARCHAR),
        @Result(column="BusinessTypeCode", property="businesstypecode", jdbcType=JdbcType.VARCHAR),
        @Result(column="Detach", property="detach", jdbcType=JdbcType.BIT),
        @Result(column="DataDigest", property="datadigest", jdbcType=JdbcType.VARCHAR),
        @Result(column="CertInfoID", property="certinfoid", jdbcType=JdbcType.VARCHAR),
        @Result(column="CreatedTime", property="createdtime", jdbcType=JdbcType.TIMESTAMP),
        @Result(column="LastTime", property="lasttime", jdbcType=JdbcType.TIMESTAMP),
        @Result(column="SourceData", property="sourcedata", jdbcType=JdbcType.LONGVARCHAR),
        @Result(column="Base64SourceData", property="base64sourcedata", jdbcType=JdbcType.LONGVARCHAR),
        @Result(column="SignedData", property="signeddata", jdbcType=JdbcType.LONGVARCHAR),
        @Result(column="Timestamp", property="timestamp", jdbcType=JdbcType.LONGVARCHAR),
        @Result(column="SignCert", property="signcert", jdbcType=JdbcType.LONGVARCHAR)
    })
    TlkSignedDataWithBLOBs selectByPrimaryKey(String id);


    @ResultMap("dataResult")
    @Select("select * from tlk_signed_data " )
    List<TlkSignedDataWithBLOBs> select();

}
~~~


###  @Select
1、可以使用大括号，而不是使用 + 拼接sql

~~~
    @Select({"select",
        "`ID`, `Authority`, `BusinessOrgCode`, `BusinessSystemCode`, `BusinessTypeCode`, ",
        "`Detach`, `DataDigest`, `CertInfoID`, `CreatedTime`, `LastTime`, `SourceData`, ",
        "`Base64SourceData`, `SignedData`, `Timestamp`, `SignCert`",
        "from tlk_signed_data"})
    List<TlkSignedDataWithBLOBs> select();
~~~


###@Options
1、可以使用@Options来获得最新插入的id。这个signedDataPO对象在插入完成后，id会被自动填充
~~~
    /**
     * 插入id表
     *
     * @return
     */
    @Insert(value = "INSERT INTO `tlk_signed_data_id`(`id`) VALUES (NULL);")
    @Options(useGeneratedKeys = true,keyProperty = "signedDataPO.id")
    void insertId(@Param("signedDataPO") SignedDataPO signedDataPO);
~~~

###注解中使用if判断

~~~

    // 添加证书信息
    @Insert({
        "<script>" +
            "INSERT INTO BIZ_CERT_INFO(`id`, `authority`, `user_department`, `user_name`, "
            + "`identity_number`, `type_id`, `type`, `serial_number`, `check_key`, `valid_from_date`, "
            + "`valid_to_date`, `sign_cert`, `cryption_cert`, `user_id`, `sign_flow`, `hardware_code`, "
            + "`status`, `created_at`, `pwd_updated_at`,`pull_org_code`) "
            + "VALUES(#{certInfoPO.ID}, #{certInfoPO.Authority}, #{certInfoPO.UserDepartment}, "
            + "#{certInfoPO.UserName}, #{certInfoPO.IdentityNumber}, #{certInfoPO.TypeId}, "
            + "#{certInfoPO.Type}, #{certInfoPO.SerialNumber}, #{certInfoPO.CheckKey}, "
            + "#{certInfoPO.ValidFromDate}, #{certInfoPO.ValidToDate}, #{certInfoPO.SignCert}, "
            + "#{certInfoPO.CryptionCert}, #{certInfoPO.UserId}, #{certInfoPO.SignFlow}, "
            + "#{certInfoPO.HardwareCode}, #{certInfoPO.Status}, NOW(), NOW(), #{certInfoPO.pullOrgCode})"
            + "<if test='certInfoPO.SignFlow != null and certInfoPO.SignFlow != \"\"'>"
            + " ON DUPLICATE KEY UPDATE sign_flow=#{certInfoPO.SignFlow} </if> </script>"
    })
    void AddCertInfo(@Param("certInfoPO") CertInfoPO certInfoPO);

~~~

---
title: 列表页面的count.md
top: false
cover: false
toc: true
mathjax: true
date: 2022-03-20 18:16:49
password:
summary:
tags: mysql基本
categories: mysql基本
---
---
title: 列表页面的count.md
top: false
cover: false
toc: true
mathjax: true
date: 2022-03-20 18:16:49
password:
summary:
tags: mysql基本
categories: mysql基本
---
许天云:
列表页面的count大家一般是怎么处理的，都用redis做缓存，定时更新嘛

但行好事  莫问前程:
@苏州-新点-许天云 是的

许天云:
公司没这套缓存方案，我也是醉了

Ken:
表多大？

许天云:
几万到几十万不等的，看项目上的

Ken:
这个数量级，不慢吧。

许天云:
个别百万级的就不行了。

许天云:
而且是join的count

Ken:
我是这样看这个count问题的。1、是否有必要每个查询都要count，如果是OLAP的话，禁用，并修改业务逻辑。2、确实要count的，比如后台系统或报表，走从库或数据库仓库，慢点就慢点呗。3、创建一个短长度的二级非空索引来加快count的速度。4、其他redis等其他方案，我都觉得没有完美解决的方案。

Ken:
之前我们是结合了前3个，再结合业务，把每天产生几千万的单表数据切成每天一个历史表，查询历史表按天查询，再做一些数据预统计方案，缓解业务对count的需求。再后来就把这些每天写入数千万到单表的数据分离出来，不入MySQL了。

ghost:
这种count是带走条件的，而且是多个count

ghost:
条件里还有 name like %名字%

许天云:
@广州-奥园-Ken  你们是平台型的嘛

Ken:
结合你的业务需求。这个是重点。互联网OLTP，绝对是禁用like和count的。

Ken:
我现在没有了。在上家公司搞的。

ghost:
不是互联网

Ken:
那我没有经验分享了。用O吧。

Ken:
ZF不是都喜欢O的吗？

ghost:
Mysql ngram怎么样

ghost:
是政府子系统

Ken:
我觉得吧，像ZF这种系统的，OLTP和OLAP混合的，有复杂SQL查询、系统架构和程序代码又不能自己控制的，还是少用MySQL吧。要使用MySQL它擅长的方面。一定要使用，也不是不行，慢点就慢点呗，又不是不能用。

ghost:
互联网禁用count之后，是如何实现(跳转到最后一页)的

许天云:
我们公司全是政府的

ghost:
比如 查询名称包含"特斯拉"的最后一页数据

Ken:
可能我没有说清楚。互联网用户就一个ID作为主键先限制了大量的数据返回，然后才可能做一些分页，不是说全部都没有count，只是尽量避开。你在手机APP上会有很多点击下一页的操作吗？

ghost:
不是下一页。是最后一页。

Ken:
你在淘宝、京东APP搜索一下，看有没有下一页或总页数的显示 或按钮。即使有，也是做了缓存了，我觉得就不是实时的，是缓存的。

ghost:
包含"特斯拉"这种count怎么缓存呀，这么多可能性

Ken:
而且这种搜索返回大量的数据，也没必要实时。我搜索“特斯拉”，可能实时查询真实是200000页，但我给个182719页的缓存给你，你会一页一页深挖吗？你也不知道总分页数182719是否对的，其实不对也没关系。如果点最后一页，我就跳到182719给页你也行。

ghost:
关键你不知道返回182719还是返回0，因为我搜索"特斯拉"，结果没有，你还返回182719

Ken:
所以要分具体的业务场景呗。

Ken:
比如后台系统，订单系统，一定要返回真实和实时的数据，并发量可能就是少量的内部员工，那就慢点就慢点罗。结合我上面所说分表，历史查询，创建二级索引等。

ghost:
并发很少的，可以忽略。只是实时性要求高点

Ken:
如果是面对数据千万的互联网用户，人家用个APP，搜索个页面，等了几秒都不返回，我估计你也不想用。

ghost:
count很久的。但返回一个假数字，那当搜索结果很少，返回多大数字合适呢

ghost:
难搞哦

Ken:
需要我重复吗？

ghost:
关系型数据库都面对这种场景，都无解啊

ghost:
即使oracle

wenming:
我有个不成熟的想法，能不能把 count 转成 query，就是把 redis 缓存的功能移到 mysql 里面，设计表的时候加一列 count，把相关业务统计的指标放到表里面

wenming:
每次增删改，都修改 count 字段

熊猫:
这方案~怎么解决高并发？

花海:
我们Oracle现在有一个定时任务会对一个表执行一千次更新，然后Oracle就挂了，执行500次更新就没问题，这是怎么回事啊？这种有什么解决办法吗？懂Oracle的大佬给解决一下

Ken:
O在少量并发的复杂查询，count还是可以的，毕竟不是B+树。但在大并发下就要用MySQL及相应的配套了。

ghost:
O用的是啥树

Ken:
redis的解决方案，可以参考下丁奇老师的课程。

wenming:
这个的确对并发不友好

Michael Liu:
请问各位大佬，一个表如果建了唯一索引，update语句全部都走了唯一索引，新建的二级索引不生效，这个有什么优化方法吗？

wenming:
但是对大数据量应该还不错

ghost:
条件组合很多哦，都要穷举吗？比如name

wenming:
count 的条件就看表的设计和业务了，划分好层级，每层查询，然后代码累计，

wenming:
这只是突然想到的，不是正规的做法

wenming:
正常的做法，肯定是异步到 es 或者 redis 里面，

ghost:
这倒是可以

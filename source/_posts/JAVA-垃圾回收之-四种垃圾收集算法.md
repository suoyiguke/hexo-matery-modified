---
title: JAVA-垃圾回收之-四种垃圾收集算法.md
top: false
cover: false
toc: true
mathjax: true
date: 2022-03-20 18:16:49
password:
summary:
tags: JAVA-GC
categories: JAVA-GC
---
---
title: JAVA-垃圾回收之-四种垃圾收集算法.md
top: false
cover: false
toc: true
mathjax: true
date: 2022-03-20 18:16:49
password:
summary:
tags: JAVA-GC
categories: JAVA-GC
---
###引用计数法
####用在哪里？
JVM实现一般不采用此方式，但是在微软的com语言、ActionScript、Python中使用到
####原理？
每个对象有一个引用计数器，当对象被引用一次则计数器加1，当对象引用失效一次则计数器减1，对于计数器为0的对象意味着是垃圾对象，可以被GC回收。
![image.png](https://upload-images.jianshu.io/upload_images/13965490-61f4d78b6757a829.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
###优势劣势？

缺点：
  - 每次对对象赋值时均要维护引用计数器，且计数器本身也有一定消耗
 - 较难处理循环引用
出现循环引用问题的代码: 即使是将objA 、objB都复制为null，因为 objA.instance = objB;objB.instance = objA; 循环引用。内存就不会别GC回收
~~~
public class TestGc {
    private byte[] bigArr=new byte[2*1024*1024];//2m  2*1024k
    Object instance = null;

    public static void main(String[] args) {

        TestGc objA = new TestGc();
        TestGc objB = new TestGc();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
        System.gc();
    }
}
~~~


###复制算法（Copying）
####用在哪里？
新生代的中的对象基本都是朝生夕死的（90%以上）所以，新生代中使用的是Minor GC ，这种GC算法采用的是复制算法
####原理？
当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳(上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，`则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中`，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1

当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。  但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。

![image.png](https://upload-images.jianshu.io/upload_images/13965490-91240e40ba0e1b7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
####复制算法针对的内存？
存活的对象，将存活的对象复制一份到to区中





####设置对象在新生代的存活次数
~~~
 -XX:MaxTenuringThreshold
~~~



####优势劣势？
不会产生内存碎片；费空间

1、它浪费了一半的内存，这太要命了。
2、如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。

###标记清除（Mark-Sweep）
####用在那里？
老年代一般是由标记清除或者是标记整理（标记清除的标记阶段+标记压缩）的混合实现
####原理？
算法分为标记和清除两个阶段，先标记处要回收的对象。然后统一回收这些对象。

![image.png](https://upload-images.jianshu.io/upload_images/13965490-6b11b45490ea3ce6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
在程序运行期间，可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将要回收的对象标记一遍，最终统一回收这些对象，完成标记清理工作接下来便让应用程序恢复执行


####标记清除针对的内存
可回收的对象/被标记成垃圾的对象

####优势劣势？
相对于复制算法来讲节约内存空间；效率低、产生不连续的内存碎片

1、首先，它的缺点是效率比较低（递归与全堆对象遍历，需要扫描两次），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲
2、其次，主要的缺点则是这种方式清理出来的空闲空间是不连续的，这点不难理解，我们的死亡对象都是随机出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应对这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。

###标记整理
####用在那里？
老年代一般是由标记清除或者是标记整理（标记清除的标记阶段+标记压缩）的混合实现
####原理?
标记整理其实就是在标记清除的标记阶段之上在加一个“标记压缩”

![image.png](https://upload-images.jianshu.io/upload_images/13965490-d1d63dc5c0b35f46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

在整理压缩阶段，不再对标记的对象做回收（这是和标记清除的不同之处，标记清除标记随后就是清除了），而是通过所有存活对象都向一端移动，然后直接清除边界以外的内存。
可以看到，标记的存活的对象将会被整理，按照内存地址依次排列，而未 被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，`JVM只需要持有一个内存的起始地址即可`，这比维护一个空间列表显然少了许多开销


####优势劣势？
节约内存、不产生内存碎片；效率不高，耗时


标记清除算法唯一的缺点就是效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址；从效率上来说，标记/整理算法要低于复制算法。


###垃圾回收算法的比较
效率：复制算法>标记/整理算法>标记/清除算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。

内存整齐度：复制算法=标记/整理算法>标记/清除算法。

内存利用率：标记/整理算法=标记/清除算法>复制算法。

- 可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存

- 而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程

- 说白了就是时间和空间的选择；复制算法就是牺牲空间换时间了

 
###如何选择使用这些垃圾回收算法？
分代收集算法==>没有最好的算法，只能根据每一代垃圾的特性，选择合适的算法；

新生代使用复制算法，老年代使用标记清除、标记整理

###年轻代垃圾特点
- 区域相对老年代较小（与老年代大小比值是1:2）
- 对象存活率低（90%死亡）


这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因而很适用年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中两个survivor的设计得到缓解。
`复制算法只复制存活的对象，而在年轻代中存活的对象非常少，所以速度就快`

###老年代垃圾特点
- 区域较大（是年轻代的2倍）
- 对象存活率高
这种情况，存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记清除或标记清除与标记整理的混合实现

`标记清除与标记整理算法只标记死亡对象，而老年代中死亡的对象非常少`

---
title: java-多线程编程之必知概念.md
top: false
cover: false
toc: true
mathjax: true
date: 2022-03-20 18:16:49
password:
summary:
tags: juc
categories: juc
---
---
title: java-多线程编程之必知概念.md
top: false
cover: false
toc: true
mathjax: true
date: 2022-03-20 18:16:49
password:
summary:
tags: juc
categories: juc
---
###线程和进程
进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。`它是操作系统动态执行的基本单元`，在传统的操作系统中，`进程既是基本的分配单元，也是基本的执行单元`。
 
线程：通常在`一个进程中可以包含若干个线程`，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度


###并发
程序同时拥有两个或多个线程，如果程序在单核处理器上运行，`（单核处理器无法真正的并发执行）`;多个线程将交替地换入或者换出内存，这些线程是同时“存在”的，每个线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时，程序中的每个线程都将分配到一个处理器上，因此可以同时运行。

###高并发
高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过保证系统能够并行处理很多请求。

**并发、高并发 二者的侧重点**
并发和高并发的侧重点其实还是有一些细微的不同，在谈到并发时候，我们侧重于多个线程操作相同的资源，保证线程安全，合理利用资源。高并发是在系统运行的过程中短时间内遇到大量操作请求的情况，要求服务可以同时处理很多请求，提高程序性能。

###并行性
并行性，不是并发，强调的是多个线程在某一时刻`同时开始执行`。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑;JUC包下有一些工具类可以实线程并行执行

###同步和异步
同步和异步通常用来形容一次方法调用。同步方法调用一开始，调用者必须等待被调用的方法结束后，调用者后面的代码才能执行。而异步调用，指的是，调用者不用管被调用方法是否完成，都会继续执行后面的代码，当被调用的方法完成后会通知调用者。

javascript的ajax就是可以异步的，调用ajax函数发起请求后将继续下面的代码；直到请求响应，触发回调函数

###线程同步
同步即是`线程排队执行`；java中最常见的同步机制就是`synchronized`机制了



###java中的线程阻塞
- 等待阻塞: 等待阻塞是调用wait方法产生的,对应的线程状态是waiting/timted_waiting
- 同步阻塞: 同步阻塞则是由同步块（synchronized）产生的，对应的线程状态是 blocked
- 以及其他阻塞（睡眠、join或者IO阻塞）, 睡眠阻塞是由sleep产生的，join阻塞是由join方法产生的。

### 临界区
临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每个线程使用时，一旦临界区资源被一个线程占有，那么其他线程必须等待。
- 获得锁进入临界区获，退出临界区释放锁；
- Object.wait()方法执行则退出临界区；
- 比如synchronized块里面的代码就是一个“临界区”；进入synchronized块则进入临界区获得锁，执行完毕synchronized块则退出临界区释放锁



###CPU执行时间片竞争策略

在操作系统中，CPU竞争有很多策略，Unix系统采用的是时间片算法，而Windows采用的是抢占式的

**时间片算法**
在时间片算法中，所有的进程排成一个队列。操作系统按照他们的顺序，给每个进程分配一段时间，即该进程允许运行的时间。如果在 时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程 序所要做的就是维护一张就绪进程列表，，当进程用完它的时间片后，它被移到队列的末尾。
**抢占式**
而Windows采用的是抢占式的。
抢占式操作系统，就是说如果一个进程得到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU 。因此可以看出，在抢占式操作系统中，操作系统假设所有的进程都是“人品很好”的，会主动退出 CPU 。在抢占式操作系统中，假设有若干进程，操作系统会根据他们的优先级、饥饿时间（已经多长时间没有使用过 CPU 了），给他们算出一 个总的优先级来。操作系统就会把 CPU 交给总优先级最高的这个进程。当进程执行完毕或者自己主动挂起后，操作系统就会重新计算一次所有进程的总优先级，然后再挑一个优先级最高的把 CPU 控制权交给他。

###CPU上下文切换
时间片是CPU分配给各个线程的时间，因为时间非常短，所以CPU不断通过切换线程，让我们觉得多个线程是同时执行的，时间片一般是几十毫秒。悲观锁会导致频繁的上下文切换，而频繁的上下文切换可能无法发挥出多线程编程的优势。而每次切换时，需要保存当前的状态起来，以便能够进行恢复先前状态，而`这个切换时非常损耗性能`，过于频繁反而无法发挥出多线程编程的优势。通常减少上下文切换可以采用`无锁并发编程`，`CAS算法`，`使用最少的线程`和`使用协程`。

因为非常损耗性能，需要尽量避免上下文切换

###Java 程序中怎么保证多线程的运行安全？
线程的安全性问题体现在：

原子性：一个或者多个操作在 CPU 执行的过程中不被中断的特性
可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到
有序性：程序执行的顺序按照代码的先后顺序执行
 
导致原因：

工作内存缓存导致的可见性问题
线程切换带来的原子性问题
编译优化指令重排序带来的有序性问题
 
解决办法：

JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题
synchronized、volatile、LOCK，可以解决可见性问题
Happens-Before 规则可以解决有序性问题

---
title: mysql-主从同步问题汇总.md
top: false
cover: false
toc: true
mathjax: true
date: 2022-03-20 18:16:49
password:
summary:
tags: mysql运维操作
categories: mysql运维操作
---
---
title: mysql-主从同步问题汇总.md
top: false
cover: false
toc: true
mathjax: true
date: 2022-03-20 18:16:49
password:
summary:
tags: mysql运维操作
categories: mysql运维操作
---
###主从复制中断错误
1、Slave_IO_Running 为yes；Slave_SQL_Running 为no；Last_SQL_Error为
Error 'Table 'zf' already exists' on query. Default database: 'test1'. Query: 'CREATE TABLE zf  (...
Last_Errno为1050;错误就是：
master中执行了一个 CREATE TABLE zf  语句创建成功，从而发送到slave时，因为slave中已经存在这个表所以执行失败了。然后接下来的所有master中库的改动就不能应用到slave中了。如果将1050错误忽略，那么接下来master的所有对zf表的操作都不能同步到slave了。

那么遇到这个错误就要如何从中断同步中恢复过来呢？
①、找到出错的master_log_file和pos值。这些信息一般会在err中有提示可以自己找下
②、重新设置slave的同步坐标参数到出错的master_log_file和pos值
~~~
stop slave;
CHANGE MASTER TO master_log_file='mysql-bin.000025',master_log_pos=2856;
start slave;
~~~
重新start slave后slave就会自动从指定pos位置去拉取并更新同步了。

防患于未然：为了防止出现这种slave中已经存在的表然后master又进行create。我们可以直接禁用在salve中修改数据，只是在slave中进行查询。就是一种读写分离思想。


2、Slave_IO_Running 为yes；Slave_SQL_Running 为no； 
 Last_Error:Could not execute Write_rows event on table test1.zf; Duplicate entry '2' for key 'PRIMARY', Error_code: 1062; handler error HA_ERR_FOUND_DUPP_KEY; the event's master log mysql-bin.000025, end_log_pos 3443
Last_Errno: 1062 错误就是：
master中执行了一个inert table id=2 的指定主键插入的语句，从而发送到slave时，因为slave中已经存在这个主键对应记录所以执行失败了。导致复制中断。
这里的报错已经是把出错的两个坐标参数都提示了，那么就很容易进行主从复制恢复了。
~~~
stop slave; 
CHANGE MASTER TO master_log_file='mysql-bin.000025',master_log_pos=3443; 
start slave;
~~~

3、Slave_IO_Running 为yes；Slave_SQL_Running 为no；
Last_Error：Error 'Unknown table 'test1.zf'' on query. Default database: 'test1'. Query: 'DROP TABLE `zf` /* generated by server */'
Last_Errno为 1051 为从库同步主库的drop table而表不存在时报的错。我们可以通过查看master的binlog信息来得到坐标信息：
![image.png](https://upload-images.jianshu.io/upload_images/13965490-91c47728e807851e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
4176 是执行完drop时，我们就是要得到drop执行之后的所有主库未同步到从库的binlog信息。那么就选择4176作为新的同步点。
~~~
stop slave; 
CHANGE MASTER TO master_log_file='mysql-bin.000025',master_log_pos=4176; 
start slave;
~~~


###zzzz
2、Slave_IO_Running 为no ；Last IO error 显示
Fatal error: The slave I/O thread stops because master and slave have equal MySQL server ids; these ids must be different for replication to work (or the --replicate-same-server-id option must be used on slave but this does not alway
原因分析： 调整maste和slave的server_id 为不同的值。不过不知道为什么我设置为1和2还是报这个错。设置为3305和3306就解决了

3、mysql5.7主从复制要求master和slave直接不光是server_id要不同，还需要server_uuid也不同。若使用的是同一个mysql绿色版压缩包就会相同了

Last_IO_ErrorFatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work.

原因分析：mysql 5.7的复制引入了uuid的概念，各个复制结构中的server_uuid得保证不一样，但是查看到直接copy  data文件夹后server_uuid是相同的
~~~
show variables like '%server_uuid%';
~~~
解决方法：找到data文件夹下的auto.cnf文件，修改里面的uuid值，保证各个db的uuid不一样，重启db即可




4、在mysql实例重启后需要再手动开启同步，在slave中执行show slave status;得到last_sql_error 字段信息如下
>Error executing row event: 'Cannot execute statement: impossible to write to binary log since statement is in row format and BINLOG_FORMAT = STATEMENT.'

我产生的原因是 主从都使用STATEMENT的binlog，innodb_autoinc_lock_mode 设置为 2。这种情况会导致主从自增id出现不统一。主从复制也报这个错。将innodb_autoinc_lock_mode 修改为1（会降低自增主键生成性能）或者将BINLOG_FORMAT 设置为row也可解决


5、在一台主机上增加一个slave，启动的时候报
[ERROR] Slave SQL: Slave failed to initialize relay log info structure from the repository, Error_code: 1872
出现原因：salve中必须配置中继日志。
~~~
[mysqld]
## relay_log配置中继日志
relay_log=replicas-mysql-relay-bin
~~~


6、
LAST_ERROR 1032

Could not execute Update_rows event on table iam.biz_cert_info; Can't find record in 'biz_cert_info', Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event's master log mysql-bin.000001, end_log_pos 1952985


7、Got fatal error 1236 from master when reading data from binary log: 'Could not find first log file name in binary log index file'
这是主库的binlog变动太大导致的问题，可能是主库的binlog已经被重置。此时我们从机重置下就行了
~~~
stop slave;
reset slave;
start slave
~~~



8、 Slave is not configured or failed to initialize properly. You must at least set --server-id to enable either a master or a slave. Additional error messages can be found in the MySQL error log. 因为配置了这个master_info_repository=TABLE relay_log_info_repository=TABLE，主从同步的同步master进度信息和引用中继日志进度信息都会被保存在table中。可能因为最近的主机进度丢失或者做了迁移操作

解决步骤：

1、drop 备份的 ibd表
use mysql
drop table slave_master_info;
drop table slave_relay_log_info;
drop table slave_worker_info;
drop table innodb_index_stats;
drop table innodb_table_stats;
2、重建


mysql> source /usr/local/mysql/share/mysql_system_tables.sql
Query OK, 0 rows affected, 1 warning (0.00 sec)　
3、重启数据库


[root@mysql01 data]# usr/local/mysql/bin/mysqld restart
Shutting down MySQL..                                      [  OK  ]
Starting MySQL..                                           [  OK  ]
　 至此，问题解决，登陆数据库，重新 change master to 即可！

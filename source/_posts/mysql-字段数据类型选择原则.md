---
title: mysql-字段数据类型选择原则.md
top: false
cover: false
toc: true
mathjax: true
date: 2022-03-20 18:16:49
password:
summary:
tags: mysql基本
categories: mysql基本
---
---
title: mysql-字段数据类型选择原则.md
top: false
cover: false
toc: true
mathjax: true
date: 2022-03-20 18:16:49
password:
summary:
tags: mysql基本
categories: mysql基本
---
###尽量选择范围小的数值类型

###尽量使用整型表示字符串

请使用mysql内建类型来存储时间等，而不是使用字符串！我待过的小公司全部使用字符串来存储所有的数据类型。这对我造成了很大的影响，之前我一直以为使用字符串存储比较好。

> 整型比字符串操作的代价更低，因为字符集和较对规则（排序规则）使得字符比较比整型比较更复杂。

1、11位手机号可以使用bigint存储

为什么不使用 char(11) ？
Latin1的char(11)占用11字节而bigint占用8字节
为什么不使用int？
int范围 -2147483648 --- 2147483647  十位数字而已，就算使用无符号 unsigned 也容纳不了一个11位的手机号。因此需要使用 bigint

2、使用unsigned int 存储 ip
我们可以使用下面的函数实现 ip转为数值存储到mysql，可以把IP与`最大长度为10位`的数值类型互转
`INET_ATON(str)`，address to number
`INET_NTOA(number)`，number to address

需要使用 unsigned 的 11位 int，若不加无符号则会溢出


3、添加一个冗余列来优化索引查询，使用数值类型存储url字符串

为什么要使用数值类型存储url？
在字符串类型的url字段上加索引效率并不高！前几位的http是重复的。为此我们可以这样做：考虑在表中新增一个冗余字段来存储url的伪hash值。在mysql中我们可以使用crc32('a') 函数来得到url对应的数值。然后在数值上建立索引，在插入数据时将url对应的数值插入到库中。

创建表，创建索引，插入数据
~~~
CREATE TABLE `t2`  (
  `id` int(11) NOT NULL,
  `url` varchar(5000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `crcurl` bigint(11) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `crcurl`(`crcurl`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;
INSERT INTO `t2` VALUES (1, 'https://www.baidu.com', CRC32('https://www.baidu.com'));
~~~

查询
~~~
EXPLAIN SELECT * FROM `t2` WHERE crcurl = CRC32('https://www.baidu.com')
~~~

也有另一种算法来生成url的标识
~~~
SELECT CONV(RIGHT(MD5('http://www.mysql.com/'), 16), 16, 10)
~~~

4、使用mysql内建类型来存储时间而不是字符串

使用DATETIME或TIMESAMP而不是直接使用字符串存储时间！很多人图省事就直接使用字符串类型存储时间了，因为可以避免很多时间转换操作，但是这对mysql存储和查询都没好处。




###常见数据类型选择
姓名：char(20)
年龄：tinyint(4)
各种状态：tinyint(4) （不推荐使用枚举，枚举不好扩展选项）
价格：DECIMAL(7, 3)
文章内容: LONGTEXT
BASE64: LONGTEXT 
手机号：bigint(11)
自增主键：unsigned bigint(20)
md5: char(32) 
uuid:char(32)、char(36)
ipv4: 借用inet_aton/inet_ntoa函数，使用 unsigned  int(11) 
time: int(10)
email:char(32)
身份证号码：char(18)
地址：varchar(50)
文章：longtext
日期时间：datetime
url冗余列：bigint(11)

###小细节
使用tinyint(4)，不使用tinyint(1)的原因是tinyint(1)会被orm框架认为是布尔类型，在生成实体类时。直接被翻译成布尔类型而不是Integer类型





###姜老师

1、不推荐使用整型类型的属性 Unsigned，若非要使用，参数 sql_mode 务必额外添加上选项 NO_UNSIGNED_SUBTRACTION；




2、自增整型类型做主键，务必使用类型 BIGINT，而非 INT，后期表结构调整代价巨大；

3、MySQL 8.0 版本前，自增整型会有回溯问题，做业务开发的你一定要了解这个问题；

4、当达到自增整型类型的上限值时，再次自增插入，MySQL 数据库会报重复错误；

5、不要再使用浮点类型 Float、Double，MySQL 后续版本将不再支持上述两种类型；

6、敲黑板3）在海量互联网业务的设计标准中，并不推荐用 DECIMAL 类型，而是更推荐将 DECIMAL 转化为 整型类型。账户余额字段，设计是用整型类型，而不是 DECIMAL 类型，这样性能更好，存储更紧凑。




###数值类型

1、长字符串需要加索引可以增加一个冗余字段，存储他的crc32的值

2、而数字类型中的高精度 DECIMAL 类型可以使用，当声明该类型列时，可以（并且通常必须要）指定精度和标度，例如：
~~~
salary DECIMAL(8,2)
~~~
其中，8 是精度（精度表示保存值的主要位数），2 是标度（标度表示小数点后面保存的位数）。通常在表结构设计中，类型 DECIMAL 可以用来表示用户的工资、账户的余额等精确到小数点后 2 位的业务。

海量数据和并发下，推荐金额使用bigint，请不要使用int。int的长度是32位上限是42亿多如果以分为单位除以100当个列的值就只能存储4200万左右。


4、讲师回复： 时间不建议用整型哦，时间还是建议使用mysql原生数据类型。


4、不管是存储还是计算，尽量用整型。比如银行客户号、业务员编码


5、手机号 11位数可以使用bigint；

但是手机号的话，还是用字符串吧，有前缀的😂
讲师回复： 手机号一般设计为VARCHAR类型居多，手机号是静态数据，很少更新，也不会存在性能问题。



6、老师，boolean类型建议用什么数据类型存储呢
讲师回复： 字符串吧，T和F，再加上CHECH约束，见02小节

7、ipv6的处理
ipv4可以转换成int unsigned类型存储，以后ipv6地址可能越来越多，目前来看ipv6只能以字符串存储，大概39个字符，所以在代码层还要做个逻辑判断：如果ipv4转换成int unsigned存储，如果ipv6转换成vachar存储，这样效率会高吗？
讲师回复： INET6_ATON(expr)，这个函数可以将ipv6转化为固定16个字节
SELECT length( INET6_ATON('2001:DB8:0:23:8:800:200C:417A'))


8、除了账户余额，还有散装食品的重量，尽量不要用kg或g做最小单位，可以用1000毫克。不过，这样的话，展示给用户看时要怎么展示呢
讲师回复： 正确。展示的话交给前端业务进行处理哦~~~


9、IPV4处理

ip地址存整数类型
讲师回复： 可以，可以用函数INET_ATON(expr)，但是需要将列定义为`INT UNSIGNED`，见官方文档的说明：To store values generated by INET_ATON(), use an INT UNSIGNED column rather than INT, which is signed.


10、经纬度
讲师回复： 经纬度直接用GIS类型即可，具体见MySQL官方文档






###金额
在海量互联网业务的设计标准中，并不推荐用 DECIMAL 类型，而是更推荐将 DECIMAL 转化为 整型类型。也就是说，资金类型更推荐使用用分单位存储，而不是用元单位存储。如1元在数据库中用整型类型 100 存储。

金额字段的取值范围如果用 DECIMAL 表示的，如何定义长度呢？因为类型 DECIMAL 是个变长字段，若要定义金额字段，则定义为 DECIMAL(8,2) 是远远不够的。这样只能表示存储最大值为 `999999.99`，百万级的资金存储。

用户的金额至少要存储百亿的字段，而统计局的 GDP 金额字段则可能达到数十万亿级别。用类型 DECIMAL 定义，不好统一。

另外重要的是，类型 DECIMAL 是通过二进制实现的一种编码方式，计算效率远不如整型来的高效。因此，推荐使用 BIGINT 来存储金额相关的字段。

字段存储时采用分存储，即便这样 BIG INT 也能存储`千兆级别`的金额。这里，1兆 = 1万亿。

这样的好处是：
- 同为8字节，bigint 表示的金额范围大于DECIMAL 
- 所有金额相关字段都是`定长字段`，占用 8 个字节，存储高效。而DECIMAL是变长的。
- 另一点，直接通过整型计算，效率更高。DECIMAL因为小数与整数位分开存储与计算所以相对来说效率会低。



###整型类型与自增设计
在真实业务场景中，整型类型最常见的就是在业务中用来表示某件物品的数量。例如上述表的销售数量，或电商中的库存数量、购买次数等。在业务中，整型类型的另一个常见且重要的使用用法是作为表的主键，即用来唯一标识一行数据。

整型结合属性 auto_increment，可以实现自增功能，但在表结构设计时用自增做主键，希望你特别要注意以下两点，若不注意，可能会对业务造成灾难性的打击：

用 BIGINT 做主键，而不是 INT；

自增值并不持久化，可能会有回溯现象（MySQL 8.0 版本前）。

从表 1 可以发现，INT 的范围最大在 42 亿的级别，在真实的互联网业务场景的应用中，很容易达到最大值。例如一些流水表、日志表，每天 1000W 数据量，420 天后，INT 类型的上限即可达到。

因此，（敲黑板 1）用自增整型做主键，一律使用 BIGINT，而不是 INT。不要为了节省 4 个字节使用 INT，当达到上限时，再进行表结构的变更，将是巨大的负担与痛苦。

那这里又引申出一个有意思的问题：如果达到了 INT 类型的上限，数据库的表现又将如何呢？是会重新变为 1？我们可以通过下面的 SQL 语句验证一下：

~~~
mysql> CREATE TABLE t (
    ->     a INT AUTO_INCREMENT PRIMARY KEY
    -> );
mysql> INSERT INTO t VALUES (2147483647);
Query OK, 1 row affected (0.01 sec)

mysql> INSERT INTO t VALUES (NULL);
ERROR 1062 (23000): Duplicate entry '2147483647' for key 't.PRIMARY'
可以看到，当达到 INT 上限后，再次进行自增插入时，会报重复错误，MySQL 数据库并不会自动将其重置为 1。
~~~

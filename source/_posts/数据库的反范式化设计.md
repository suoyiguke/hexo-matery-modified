---
title: 数据库的反范式化设计.md
top: false
cover: false
toc: true
mathjax: true
date: 2022-03-20 18:16:49
password:
summary:
tags: dba
categories: dba
---
---
title: 数据库的反范式化设计.md
top: false
cover: false
toc: true
mathjax: true
date: 2022-03-20 18:16:49
password:
summary:
tags: dba
categories: dba
---
反范式是试图通过增加冗余数据或通过分组数据来优化数据库读取性能的过程。在某些情况下，反范式是解决数据库性能和可伸缩性的极佳策略。

范式化的设计是在不同的有关系的表中存储不同的信息，如果需要查询信息往往需要连接多个表，如果连接的表很多，将会导致很多随机I/O，那么查询可能会非常慢。

一般有两种解决方案，一种做法是仍然保持范式化的表设计，但在数据库存储冗余信息来优化查询响应，由数据库来确保冗余副本数据的一致性。例如Oracle的物化视图技术，SQL Server的Indexed View技 术。

另一种做法是反范式的数据表设计。由于多了冗余数据，因此数据的一致性需要靠数据库约束或应用程序来保证。

传统商 业数据库一般通过施加数据库约束来确保数据的一致性，而互联网数据库一般靠应用程序来确保数据的一致性。 反范式的好处是减少了连接，因此可以更好地利用索引进行筛选和排序，对于一些查询操作可以提高性能。但也需要清楚 一个事实，那就是冗余数据意味着更多的写入，如果冗余的数据量很大，还可能会碰到I/O瓶颈，这会导致性能变得更差，所以需要事先衡量对各个表的更新量和查询量，评估对其他查询的影响，避免引发性能问题。

冗余数据也意味着可能要牺牲部分 数据的一致性，我们有必要区分不同数据的一致性的优先级，对于重要的、用户比较敏感的数据一定要注意一致性的问题，以 免影响用户的体验。 随着开发经验的日渐丰富，做研发的读者通常都会逐渐熟悉范式，创建一个合格的满足第三范式的数据库设计并不会太难；而对于反范式设计，由于不熟悉硬件性能和数据库机制，可能考虑就不是那么周全了。 反范式设计在统计分析、数据仓库等领域使用的比较多，通过冗余数据，增加各种统计表、中间表，数据可以更快地被加载和分析。 

以下是一些反范式的例子，一般的方法是冗余或缓存某个表的一些列到另一个表或缓存中。


###例子

1、论坛的消息表forum_message包括如下字段：msg_id、from_uid、to_uid、subject、message、post_time。由于表中只存储了会员id的信息，因此如果要显示发送给某个用户（以to_uid标识）的完整消息，还需要用from_uid去连接会员表，获取会员的姓名，在高并发的情况下，这样做可能会带来性能问题，常用的解决方案是增加1个冗余字段from_uname以避免JOIN。

2、反范式可以更好地利用索引进行筛选和排序，如上一个例子1）中，如果需要按照uname对消息进行排序，则需要连接会员表，然后按照uname进行排序，这样的代价比较高，增加冗余列uname，并在其上创建索引，就可以利用索引排序很快地回结果。对于多个列的筛选排序也可以采用类似的优化思路，例如： select table_a.* from table_a join table_b on table_a.id=table_b.id order by table_a.col_1,table_b.col_2； 或者： select table_a.* from table_a join table_b on table_a.id=table_b.id where table_a.col_1=100 order table_b.col_2； 这样的SQL语句，由于排序的列不能利用到索引，因此需要创建临时表进行排序，成本比较高。可以考虑在table_a表中冗余col_2列，并且建立复合索引（col_1，col_2）。这样不仅可以不用JOIN两张表，而且还可以利用索引进行排序。 

3、一些程序，需要发送系统信息、推荐信息给用户。一种解决方案是在后台维护一张信息表a_message，发布新消息的时 候，给t_message表的每个用户插入新的消息id。用户登录后检查消息表t_message是否有新的未读消息，为了节省空间，t_message只有信息id而没有内容，这在大量用户登录的情况下可能会导致性能问题，因为每次查询都需要JOIN另一个表 a_message以获取内容。为了以更快的速度加载数据，可以在发布信息的时候把信息内容一并插入到t_message表中。 

4、冗余数据也可以放在缓存中，比如表a，如果用户姓名已经缓存在某个缓存产品中了，如memcached，那么就可以直接从缓存中获取，而不需要再去JOIN数据库获取用户姓名了。同样的，对于表c，也可以考虑把消息内容放到缓存里。 

5、一些统计操作，比如COUNT、SUM、MAX、MIN等操作，如果计算耗费的资源比较多，可以考虑增加冗余的统计信息，或者增加额外的字段，或者增加额外的表，比如论坛的发帖统计，用户在线人数等。 例如，对于发帖统计，需要统计最近24小时的发帖数量，我们可以每个小时插入一条统计数据到统计表，这样就可以统计最近24小时的数据了，虽然这样做不够准确，但用户一般不会介意这种数据的不准确性。如果需要更精确的统计，可以在前23 个小时使用统计值，最近1个小时使用实际值即可。

 6、如果某个用户表的字段比较多（如uid、uname、upass、email、address、qq、msn……），数据量很大，超过亿级别，那么为了方便扩展，我们将把数据分片到多个表中，例如，我们对uid这个整型字段进行求模运算，把求模运算结果一样的uid存放到同一张分表中。这时，用户需要以uname登录，查询uid，以便到分表中去查询数据。因此可以增加一个`冗余表`，只存储uname 和uid的映射关系。由于这个冗余表仅有两个列，因此虽然数据量很大，但完全可以放在一张表内，也方便加载到内存中进行访问。
![image.png](https://upload-images.jianshu.io/upload_images/13965490-5fc5edf99e045b12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


###提示
要求数据库中的所有表都满足范式是不太现实的，一般生产库中会混合使用范式和反范式。很多应用程序的 数据库设计，起初都是偏向范式化的，这样做编码会简单方便，但随着流量上涨，数据量增加，往往会碰到一些性能问题，此 时就要考虑一些反范式设计。当然，大致估测到以后的流量、数据量，并能够预先考虑反范式设计会更好。建议开发人员首先 创建一个完全规范化的设计，然后为了性能原因选择性地对一些表进行反范式化设计。我们要牢记一个准则，设计的数据库应 该按照用户可能的访问路径、访问习惯进行设计，而不是严格地按照数据范式来设计
